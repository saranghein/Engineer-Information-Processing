# [소프트웨어설계] 04. 소프트웨어설계

# 소프트웨어의 설계 (Design)

## 소프트웨어 설계 모델링

-   개념: 요구사항을 만족하는 소프트웨어의 내부 구조 및 동적 행위들을 모델링하여 표현하고 분석, 검증, 명세화하는 단계
-   목적: 무엇을(What) ~ 어떻게(How)로 관점을 전환하면서 최종 제작할 소프트웨어의 청사진을 만드는 것
-   설계 모델링 시 주의사항
  -   요구사항 분석의 정확성
  -   명확성 : 복잡한 시스템을 간결하게 표현
  -   적절성 : 시스템의 구조를 명확하게 하고 각 모듈을 독립적으로 개발할 수 있게 함
  -   일관성 유지
  -   변화에 대한 대응
-   SW 개발 단계에서 프로그래밍 언어 선택 시 고려사항
  -   개발 정보시스템의 특성
  -   사용자의 요구사항
  -   컴파일러의 가용성

## 소프트웨어 설계

-   개념:
  -   소프트웨어를 구성하는 뼈대를 정의하는 것
-   구분: 상위 설계(구조 설계), 하위 설계(기능 설계)

![Untitled](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/c0a6f042-5902-4929-b32c-ee48ba10872b)

### 상위 설계 (High-Level Design)

-   개념: 전체 골조(뼈대)를 세우는 단계
-   아키텍처 설계: 시스템의 전체적인 구조
-   데이터 설계: 필요한 정보를 자료구조/데이터베이스 설계에 반영
-   시스템 분할: 여러 개의 서브 시스템으로 분리
-   인터페이스 설계: 시스템의 구조와 서브 시스템들 사이의 관계
-   사용자 인터페이스 설계: 사용자와 시스템의 관계

### 하위 설계 (Low-Level Design)

-   개념: 시스템의 내부 구조, 동적 행위 등을 결정해 제어와 데이터 간의 연결에 대해 구체적인 정의를 하는 단계
-   설계 방법: 절차기반(Procedure-Oriented), 자료위주(Data Oriented), 객체지향(Object-Oriented)

| 구분 | 상위설계 | 하위설계 |
| --- | --- | --- |
| 정의 | 기본 적인 모듈 구성 | 모듈 내부의 동작 및 세부적인 구현 방법 정의 |
| 관련 내용 | 기능적, 비기능적 요구사항 고려 | 알고리즘, 데이터 구조, 변수 등 |
| 결과물 | 아키텍처 다이어그램 | 클래스 다이어그램, 시퀀스 다이어그램 |
| 추상화 | 높은 수준의 추상화 | 낮은 수준의 추상화 |
| 구현 | 구현 단계에서 구체화 필요 없음 | 구현 단계에서 구체화 |

# 소프트웨어의 설계 대상과 방법

## 설계 대상

-   구조 모델링
  -   소프트웨어를 구성하는 컴포넌트의 유형, 인터페이스, 내부 설계 구조 등 상호 연결 구조를 모델링
  -   구성요소 : 프로시저, 데이터 구조, 모듈, 파일 구조
  -   시스템 구조: 구성 요소들의 연결구조, 포함 관계
-   행위 모델링
  -   구성요소들이 언제, 어떤 순서로 기능을 수행하고 상호작용하는지를 모델링 하는 것
  -   입출력 데이터, 데이터의 흐름과 변환, 데이터의 저장, 실행 경로, 상태 전이, 이벤트 발생 순서 등

## 설계 방법

-   구조적 설계
-   자료 중심 설계
-   객체 지향 설계

# 소프트웨어 구조도 Structure Chart

-   개념
  -   **구조적 설계** 방법 중의 하나로 시스템의 구조를 표현하는 방법
  -   그래픽 다이어그램으로 각 모듈은 상자, 모듈 간의 관계는 선으로 연결됨
-   특징
  -   각 모듈 간의 의존성을 최소화해
  -   유지 보수성을 향상 시키고
  -   시스템의 복잡도를 낮춤
  -   대규모 소프트웨어 시스템의 설계와 개발에 효과적

| 용어 | 설명 |
| --- | --- |
| Fan-in | 주어진 한 모듈을 제어하는 상위 모듈수(”영향을 받는”) |
| Fan-out | 주어진 한 모듈의 제어하는 하위 모듈 수(”영향을 주는”) |

![Untitled 1](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/4f36e1a8-1709-4cb1-be45-b81a9a7fc15e)

예) 모듈 F 에서의 Fan-in: 3, Fan-out: 2

-   Fan-in, Fan-out을 분석하면 시스템 복잡도 파악이 가능하다
  -   복잡도 최적화를 위한 조건: **Fan-in은 높**이고 **Fan-out은 낮**추도록 설계

---

# 구조적 분석 도구

\*구조적 시스템 방법론에서의 분석문서: DFD, 소단위 명세서, DD

## 자료 흐름도 (DFD: Data Flow Diagram)

-   개념
  -   시스템 내의 노든 자료 흐름을 4가지 기본 기호(처리, 자료흐름, 자료 저장소, 단말) 로 기술
  -   총체적인 **데이터 흐름** 표시
  -   다차원적이고 **자료 흐름 그래프** 또는 **버블 차트**라고도 함
  -   정의하는 방식이 명확해야 함
  -   하향식 분할 원칙

💡 시간 흐름을 명확하게 표현할 수 있는 것은 DFD가 아닌 시퀀스 다이어그램

-   작성 원칙
  -   자료 보존의 원칙 : 출력 자료 흐름은 반드시 입력 자료 흐름을 이용해 생성
  -   최소 자료 입력의원칙
  -   독립성의 원칙 : 프로세스는 오직 자신의 입력 자료와 출력 자료 자체에 대해서만 앎
  -   지속성의 원칙
  -   순차 처리의 원칙
  -   영구성의 원칙

| DFD 구성요소 | 의미 | 표기법 |
| --- | --- | --- |
| Process | 자료를 변환시키는 시스템의 한 부분 |   ![img](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/389cb21b-fc85-411b-8116-2b96e27f99af)   |
| Data Flow | 자료의 흐름 |   ![img](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/d48a99f8-ee07-4aa2-aef7-046ca7c0c9d5)   |
| Data Store | 자료저장소(파일, 데이터베이스) |   ![img](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/fb0a22ab-97a8-4222-8e6e-5654f70eede6)   |
| Terminator(단말) | 자료의 발생지, 종착지 시스템의 외부에 존재하는 사람이나 조직체 |   ![img](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/8b813233-19f0-4441-9018-2a7a8947080b)   |

## 소단위 명세서 (Mini-Specification)

-   개념:
  -   세분화된 DFD에서 최하위 단계 버블(프로세스)의 처리 절차를 기술한 것
  -   분석가의 문서이며 DFD를 지원하기 위해 작성
-   사용되는 도구
  -   구조적 언어, 선후 조건문,
  -   의사 결정표: 복잡한 의사결정 논리 기술할 때, 자료 처리 분야에서 사용
  -   의사 결정 나무: 불확실한 상황에서 의사결정할 때

## 자료 사전 (DD: Data Dictionary)

-   정의:
  -   명세와 자료 속성을 파악할 수 있도록 조직화한 도구
-   표기법
-   | 기호 | 의미 | 설명 |
        | --- | --- | --- |
    | \= | 자료의 정의 | ~로 구성(is compose of) |
    | + | 자료의 연결 | 그리고(and, along with) |
    | ( ) | 자료의 생략 | 생략할 수 있는 자료 |
    | \[ \] | 자료의 선택 | 다중 택일(selection) 또는(or), 항목간 구분은 1 |
    | { } | 자료의 반복 | $\\{\\}\_n$ : 최소 $n$번 이상 반복   $\\{\\}^n$ : 최대 $n$번 이하 반복   $\\{\\}\_m^n$ : $m$번 이상 $n$번 이하 반복 |
    | \*\* | 자료의 설명 | 주석(comment) |

-   역할: DFD의 모든 자료의 정의를 기술한 문서
-   기술해야 할 자료
  -   자료 흐름을 구성하는 자료 항목, 자료 저장소를 구성하는 자료 항목, 의미, 단위 및 값
-   작성 시 고려 사항
  -   자료의 의미 기술
  -   자료 구성 항목의 기술
  -   동의어(Alias): 동의어가 많아 혼동이 생길 수 있음, 동의어 간 서로 참조가 되는 관계 명시
  -   자료 정의의 중복 제거

---

# 모듈과 결합도 응집도

## 모듈

-   개념: 전체 프로그램에서 어떠한 기능을 수행할 수 있는 실행 코드
-   특징
  -   재사용 가능
  -   자체적 컴파일 가능
  -   노동력 절감
  -   독립성은 결합도와 응집도에 의해 측정
  -   기억장치를 유용하게 사용 가능
  -   다른 모듈과의 과도한 상호 작용 회피
-   모듈화를 통해 얻을 수 있는 것
  -   유지보수 용이성, 재사용성, 테스트 용이성, 확장성, 독립성
-   목적: 모듈 간 결합도의 최소화, 모듈 내 요소 간의 응집도 최대

## 결합도(Coupling)

-   개념: 소로 다른 두 모듈 간의 상호 의존도로 두 모듈 간의 기능적인 연관 정도를 나타냄
-   특징:
  -   결합도를 약하게 하면 모듈 독립성 향상
  -   자료 결합도가 설계 품질이 가장 좋음

| 결합도 정도 | 종류 | 설명 |
| --- | --- | --- |
| 약함   $\\uparrow$ | 자료 결합도 (Data Coupling) | 모듈 간의 인터페이스가 자료요소로만 구성, 모듈 간의 내용을 알 필요 없음 |
|   | 스탬프 결합도 (Stamp Coupling) |   |
|   | 제어 결합도 (Control Coupling) |   |
|   | 외부 결합도 (External Coupling) |   |
|   | 공통 결합도 (Common Coupling) |   |
| $\\darr$   강함 | 내용 결합도 (Content Coupling) | 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 조회하도록 설계 됨 |

## 응집도(Cohesion)

-   개념
  -   모듈 안의 요소들이 서로 관련된 정도
  -   모듈 간 최소한의 상호작용을 하여 하나의 기능 만을 수행하는 정도를 표현
-   특징
  -   “응집도가 높다” → 필요한 요소들로 구성됨
  -   “응집도가 낮다” → 요소 간의 관련성이 적음

| 응집도 정도 | 종류 | 설명 |
| --- | --- | --- |
| 강함   $\\uarr$ | 기능적 응집도 (Functional Cohesion) | 모듈 내부의 모든 기능 요소가 한 문제와 연관 |
|   | 순차적 응집도 (Sequential Cohesion) |   |
|   | 교환적 응집도 (Communicational Cohesion) |   |
|   | 절차적 응집도 (Procedural Cohesion) |   |
|   | 시간적 응집도 (Temporal Cohesion) |   |
|   | 논리적 응집도 (Logical Cohesion) |   |
| $\\darr$   약함 | 우연적 응집도 (Coincidental Cohesion) | 모듈 내부의 각 기능 요소가 서로 관련이 없는 요소로만 구성 |

## 모듈 설계 방법

-   효과적인 모듈화 설계 방법
  -   출입구를 하나씩 갖게 해 복잡도, 중복성을 줄이고 일관성 유지
  -   전반적인 기능과 구조를 이해하기 쉬운 크기로 설계
  -   모듈 간 효과적인 제어를 위해 계층적 자료 조직이 제시되어야 함
-   모듈 설계 특징
  -   “모듈 독립성이 높다” → 단위 모듈을 변경해도 타 모듈에 영향이 적음을 의미  
      ⇒ 오류 발견과 해결 쉬워짐

# 모듈과 컴포넌트

## 모듈 vs 컴포넌트

-   모듈
  -   자신 만으로 동작할 수 있는 명령의 집합
  -   실질적으로 구현이 된 단위
  -   바로 재사용 X
-   컴포넌트
  -   독립적인 기능을 수행하는 모듈로 교체가 가능한 부품
  -   실제로 동작하고 있는 엔티티
  -   **인터페이스**를 통해 연결됨

| 구분 | 모듈 | 컴포넌트 |
| --- | --- | --- |
| 목적 | 소프트웨어 복잡도 해소 | 소프트웨어 재사용성 향상 |
| 재사용 단위 | 소스코드 | 실행 코드 |
| 독립성 | 구현 언어 종속적, 플랫폼에 종속적 | 구현 언어 종속적, 동일 플랫폼 기반 개별적 연계 |
| 응용 | 단일 애플리케이션 | 분산 애플리케이션 |
| 중심 사상 | 모듈화, 추상화 | 객체지향, CBD(Component Base Development) |

## 모듈 분할

-   특징: 유지보수 쉬움, 재사용 쉬움
-   모듈 분할 시 영향을 주는 설계 형태
  -   추상화(Abstraction)
  -   모듈화(Modularity)
  -   정보은닉(Information Hiding)
  -   복잡도(Complexity
  -   시스템 구조(System Structure)

---

# 재사용과 공통 모듈

## 재사용

-   재사용 규모에 따른 구분
  -   함수의 객체
  -   애플리케이션
  -   컴포넌트

## 공통 모듈

-   개념
  -   재사용의 기본단위
  -   각 서브 시스템에서 공통으로 사용하는 기능을 묶어 하나의 공통된 모듈로 개발
-   특징
  -   모듈 재사용성을 높이고 중복 개발로 인한 낭비 없앰
  -   정합성 유지 및 중복 개발 방지
-   명세 기법: 정확성, 명확성, 완전성, 일관성, 추적성
-   공통 모듈 테스트 종류
  -   화이트박스 테스트(소스코드), 메소드 기반 테스트, 화면 기반 테스트

# 모듈 명세화 도구

-   명세화 도구의 종류
  -   Flowchart, **N-S 도표**, **Pseudo Code**, Decision Table, Decision Diagram, PDL, State Transition Diagram, Action Diagram

## N-S 도표(Nassi-Schneiderman Chart)

-   구조적 프로그램의 **순차**, **선택**, **반복**의 구조를 사각형을 도식화해 알고리즘의 논리적 기술에 중점을 둔 도형식 표현 방법
-   박스 다이어그램을 사용해 논리적인 제어 구조로 흐름을 표현
-   임의의 제어 이동 어려움
-   이해하기 쉽고 코드 변환 용이
-   제어 구조: 순차, 선택 및 다중 선택, 반복

![Untitled 2](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/38f073b5-498e-40b4-98df-c5516b04065e)

## 의사코드(Psedo Code)

-   개념
  -   프로그래밍 언어로 작성한 코드가 아닌, 사람이 이해하기 쉽도록 약속된 형식으로 작성한 코드
-   특징
  -   알고리즘을 구체적으로 나타내기 위해 사용
  -   일반적으로 프로그래밍 언어와 비슷함
  -   컴파일 되지 않음
-   의사 결정표(Decision Table)
  -   모듈의 동작을 결정하는 조건과 결과를 표로 나타낸 문서
  -   모듈의 동작을 명확하게 설명
  -   모듈의 오류를 찾는 데 도움이 됨
  -   명세화 방법: 동작을 분석, 모듈이 어떤 입력을 받고 어떤 출력을 생성하는지 파악

---

# 소프트웨어 아키텍처(Software Architecture)

## 소프트웨어 아키텍처

-   개념
  -   요구사항을 기반으로 소프트웨어의 기본 틀을 만드는 것
  -   다수의 이해 관계자가 참여하는 복잡한 개발에서 **상호 이해**, **타협**, **의사소통**을 체계적으로 접근하기 위한것
-   역할: 설계 및 구현을 위한 구조적/비 구조적인 특(Frame)을 제공
  -   Structure Frame : 컴포넌트의 구조모델
  -   Non Structure Frame : 구조모델 이외 다른 아키텍처 설계의 결정들
-   소프트웨어 아키텍처의 시스템 품질 속성
  -   가용성, 변경 용이성, 성능, 보안성, 사용편의성, 시험 용이성
-   소프트웨어 아키텍처 특징
  -   간략성, 추상화, 가시성
  -   복잡도 관리 종류: 과정 추상화, 데이터 추상화, 제어 추상화
-   평가 기준
  -   어떤 모듈로 구성?
  -   시스템은 어떻게 행동하고 연결?
  -   비 소프트웨어 구조와 어떻게 관계하고 있는 가?

## 프레임워크
- 개념
  - 반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장받을 수 있게 하는 개발 소프트웨어
- 특징
  - 일반적인 프로그램 흐름과 반대로 동작해 **IoC**(Inversion of Control)라고도 함
  - 라이브러리와 달리 사용자 코드에서 프레임워크를 호출하고 제어권도 가짐

## 아키텍처 프레임워크 구성 요소

-   아키텍처 프레임워크
  -   복잡한 소프트웨어 문제를 해결하거나 서술하는 데 필요한 기본 구조를 제공함으로써 재사용이 가능하게 함
-   구성요소
  -   AD (Architecture Description) : 기록하기 위한 산출물
  -   이해관계자 (Stakeholder)
  -   관심사(Concerns)
  -   관점(Viewpoint)
  -   View : 4+1 View

## 소프트웨어 아키텍처 설계

-   설계 원리: 단순성, 효율성, 분할(계층화), 추상화, 모듈화
-   설계 과정
  -   설계 목표 설정 → 시스템 타입 결정 → 스타일 적용 및 커스터마이즈  
      → 서브 시스템의 기능, 인터페이스 동작 작성 → 아키텍처 설계 검토

## 소프트웨어 아키텍처 평가 방법론

-   평가 방법론 유형
  -   Scenario Based : 미리 정의된 Profile에 의존해 평가, ATAM, SAAM
  -   Simulation Based : BMT(BenchMarking Test)
  -   Experience Based
  -   Mathematical Model Based : 수학적 기반 모델
-   평가 방법론의 종류 ⭐
  -   **S**AAM, **A**TAM, **C**BAM, **A**RID, **A**DR

## 소프트웨어 아키텍처 4+1 View Model

-   개념:
  -   다양하고 동시적인 View를 기반으로 소프트웨어 위주 시스템의 아키텍처를 묘사하는 View 모델
  -   다양한 측면을 고려하기 위해 다양한 관점을 바탕을 바탕으로 정의한 모델
  -   5계층 분류

| 구성 | 설명 |
| --- | --- |
| Usecase View | 설계하는 작업 |
| Logical View | 기능적인 요구사항이 어떻게 작동되는지 |
| Process View | 비기능적인 속성(비동기, 이벤트 처리 등) |
| Implementation View | 정적인 모듈의 구성, 구조와 의존성을 보여줌 |
| Deployment View(배포뷰) | 배치 연결작업이 어떻게 실행되는지 매핑해서 보여줌 |

![Untitled 3](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/5d1b5469-123d-49d5-83ac-eb9998f21842)

---

# 소프트웨어 아키텍처 패턴

## 아키텍처(Architecture) 패턴

- 개념:
    - 소프트웨어 아키텍처를 설계하는 데 발생하는 문제점을 해결하기 위한 재사용 가능한 솔루션
    - 디자인 패턴과 유사하나 더 큰 범위
- 종류 : Layered, Client-Server, Mater-Slave, Pipe-Filter, Broker, Peer to Peer, Event-Bus, MVC, Blackboard, Interpreter
- 장점: 개발 시간 단축, 고품질 소프트웨어, 간편한 의사소통, 유지보수에 유리

### 계층(Layered) 구조 패턴

소프트웨어를 계층단위(Unit)으로 나누며, N-tier 아키텍처 패턴이라고도 함

- 3계층
    - Presentation Layer, **Application** Layer, Data Layer
- 4계층
    - Presentation Layer, **Persistence** Layer, **Business** Layer, Data Layer

### MVC(Model View Controller) 패턴

Model, View, Controller로 구성되고 UI와 비즈니스 로직을 분리해 유지보수성과 재사용성을 향

![Untitled 4](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/1d6b4f36-7189-4722-8c24-bff07214b91c)

| MVC 패턴의 구성 | 설명                                                 |
| --- |----------------------------------------------------|
| Model | 데이터와 비즈니스 로직 관리,<br>사용자가 편집하기 원하는 모든 데이터를 가지고 있어야 함 |
| View | 레이아웃과 화면을 처리,<br>모델이 가지고 있는 정보를 따로 저장하면 안 됨        |
| Controller | 명령을 Model, View 부분으로 라우팅,<br>모델이나 뷰에 대해서 알고 있어야 함  |
- 장점: 유지보수 용이성, 재사용성, 확장성
- 단점: 구현 복잡성(의존성 높음), 성능 저하(데이터 전달 과정에서), 학습 비용

### 클라이언트 서버(Client Server) 패턴

하나의 서버와 다수 클라이언트로 구성

- 클라이언트가 서버에 서비스를 요청
- 서버는 응답을 위해 항상 대기 중

### 파이프 필터(Pipe-Filters) 패턴 ⭐

데이터 흐름(Data Stream)을 생성하고 처리하는 시스템을 위한 구조

- 필터:
    - 파이프를 통해 받은 데이터 변경, 결과 파이프로 전송,어휘 분석, 파싱, 의미 분석, 코드 생성 수행
- 필터 컴포넌트 : 처리 과정
- 파이프:
    - 처리되는 데이터 흐름, 버퍼링 또는 동기화 목적으로 사용

![Untitled 5](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/50a7e3d5-32fb-4a6a-9153-0f87dbe7601f)

- 장점: 필터 교환과 재조합을 통한 높은 유연성, 확장성, 사용성
- 단점: 비용 소요, 데이터 변환에 과부화, 성능 저하, 복잡성, 의존성
- 활용: 컴파일러, 구문 분석, 의미 분석, 코드 생성

### Peer to Peer 패턴

*클라이언트-서버* + 대칭적 특징

- Peer가 하나의 컴포넌트로 대응됨
- 컴포넌트는 클라이언트, 서버 역할 모두 수행
- 분산 컴퓨팅 애플리케이션 구축 시 유연성 제공

### 브로커(Broker) 패턴
컴포넌트가 컴퓨터와 사용자를 역할
- 분산 시스템에 주로 사용
- 중앙 집중식 서버(Broker)가 존재해 Broker가 메시지 전달

### 블랙보드(Blackboard) 패턴

문제를 풀어가는 하나의 방식을 정의

### 이벤트 버스(Event-Bus) 패턴

소스 이벤트가 메시지를 발행하면 해당 채널 구독자가 메시지 수신 후 이벤트를 처리하는 방식

### 인터프리터(Interpreter) 패턴

특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용 

---

# 코드 설계

*프로그래밍 코드가 아닌 자료를 분류하기 위한 코드

- 개념
    - 데이터의 사용 목적에 따라서 식별하고 분류 하기 위하여 사용하는 숫자, 문자, 또는 기호
    - 그룹으로 분류, 순번으로 나열해 체계화함
- 설계 순서
    - 코드 대상 선정 → 코드화 목적 명확화 → 코드 부여 대상 수 확인 → 사용 범위 결정 → 사용 시간 결정 <br>
    → 코드화 대상의 특정 분석 → 코드 부여 방식 결정 → 코드의 문서화
    - 코드와 항복 선정 → 사용 범위와 사용 기간 결정 → 코드화 항목의 특성 분석 → 코드 설계와 체크 <br>
    → 코드의 번역, 코드표 작성 → 코드 파일의 작성 → 코드 파일과 코드표 관리
- 설계 시 고려사항 : 기계처리의 적합성, 편리성, 코드의 공통성, 체계성, 유연성
- 특성
    - 고유성, 분류 편리성, 배열의 효율성, 간결성, 유지보수 편리성,
    - 코드의 독립성, 코드의 편의성, 추가 및 삭제 편리성

| 코드의 기본적 기능 | 코드의 3대 기능 | 코드의 부가적 기능 |
| --- | --- | --- |
| 표준화 기능 | 분류 기능 | 연상 기능  |
| 간소화 기능 | 식별 기능 | 암호화 기능 |
|  | 배열 기능 | 오류 검출 기능 |

# 코드의 분류

## 순차 코드(Sequence Code)

어떤 일정한 배열로 일련번호를 배당

- 항목 수가 적고, 변경이 적은 자료에 적합
- 일정 순서대로 코드 할당

## 블록 코드(Block Code, 구분 코드)

미리 공통의 특성에 따라서 임의의 크기를 블록으로 구분해 각 블록 안에서 일련 번호를 배정

- 기계처리가 어려움

## 그룹 분류식 코드(Group Classification Code)

기준에 따라 대분류, 중분류, 소분류로 구분하고 순서대로 번호를 부여

## 10진 분류 코드(Decimal Code, DDC)

주로 도서 분류 코드에 사용

- 예) 100 : 국문학, 200 : 철학

## 표의 숫자 코드(Significant Digit Code, 유효숫자 코드) ⭐

길이, 넓이, 부피, 무게 등을 나타내는 문자나 숫자, 기호를 그대로 사용

- 추가 및 삭제가 쉬움
- 같은 코드를 반복 사용해 오류 적음
- 예) 127-890-1245 : 두께-127mm, 폭-890mm, 길이-1245mm의 강판

## 연상 코드(Mnemonic Code, 기호 코드)

품목 명칭 일부를 코드 속에 넣음

- 예) TV-39-C : TV 39인치 컬러

## 코드의 오류 종류

| 구분 | 의미 | 예 |
| --- | --- | --- |
| 필사 오류(Transcription Error) | 한 자리 잘못 기록 | 1234 → 1237 |
| 전위 오류(Transposition Error) | 좌우 자리 바꿈 | 1234 → 2134 |
| 이중 오류(Double Transposition Error) | 전위 오류가 두 개 이상 발생 | 1234 → 2143 |
| 생략 오류(Missing Error) | 한 자리 빼고 기록 | 1234 → 123 |
| 추가 오류(Addition Error) | 한 자리 추가해 기록 | 1234 → 12345 |
| 임의 오류(Random Error) | 두 가지 이상의 오류가 결합 | 1234 → 21345 |