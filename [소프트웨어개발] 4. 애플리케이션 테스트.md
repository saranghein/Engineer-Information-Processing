# [소프트웨어개발] 4. 애플리케이션 테스트

# 소프트웨어 테스트

- 소프트웨어 개발 단계에서 사용자 요구사항에 서술된 동작과 성능, 사용성, 안정성 등을 만족하는지 확인하기 위해 소프트웨어의 결함을 찾아내는 활동
- 품질 향상 관점 : 신뢰도 향상
- 오류 발견 관점 : 오류를 발견하고 수정
- 오류 예방 관점 : 코드 리뷰, 동료 검토, 인스펙션 등을 통해 오류를 사전에 발견하는 활동
- Test Process
    - 계획 및 제어 → 분석 및 설계 → 구현 및 실행 → 평가 및 보고
- 목적에 따른 테스트
    - 성능(Performance) : 응답 시간, 처리량 테스트
    - 회복(Recovery) : 고의로 부하를 가해 실패를 유도하고 올바르게 복구되는지 테스트
    - 구조(Structured) : 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가
    - 회귀(Regression) : 변경 및 수정된 코드에 새로운 결함이 없을 확인
    - 안전(Security) : 불법적인 침입으로부터 시스템을 보호할 수 있는지 확인
    - 강도(Stress) : 과도하게 부하를 가하여도 정상적으로 실행되는지 확인
    - 병행(Parallel) : 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력해 두 결과 비교

## 소프트웨어 테스트의 원리

- **결함이 존재함을 밝히는 활동**
    - 결함이 없다고 증명할 수는 없음
- **완벽한 테스팅은 불가능**
- **테스팅은 개발 초기에 시작**
- **결함 집중(Defect Clustering)**
    - 애플리케이션 결함의 대부분은 **파레토의 법칙**에 따라 소수의 특정한 모듈에 집중되어 발생
- **파레토의 법칙(Law of Pareto) ⭐**
    - 80대 20법칙 또는 2대 8 법칙
    - 20%에 해당하는 부분에서 오류가 80% 발생
- **살충제 패러독스(Pesticide Paradox) ⭐**
    - 동일한 테스트 케이스로 반복 테스트 시 어느 시점부터 더 이상 결함을 발견할 수 없으므로
    - 주기적으로 테스트 케이스를 리뷰하고 개선해야 함
    - 탐색적 테스팅, JIT테스팅 등의 경험 기반 접근을 통한 테스트 케이스 개선
- **테스팅은 정황(Context)에 의존**
    - 정황과 비즈니스 도메인에 따라 테스트를 다르게 수행
- **오류-부재의 궤변(Absence of Errors Fallacy)**
    - 요구사항을 만족하지 못하는 오류를 발견하고 그 오류를 제거했다 해도 품질이 높다고 말할 수 없음

## 소프트웨어 테스트의 품질 척도

- 컴퓨터 프로그램이 얼마나 쉽게 테스트할 수 있는 가에 대한 성질
- 테스트 용이성을 염두에 두고 설계해야 함
- 구분
    - 작동성(Operability), 관찰성(Observability), 조종성(Controllability), 분해성(Decomposability), 단순성(Simplicity), 안정성(Stability), 이해성(Understandability)

---

# 테스트 케이스(Test Case)

- 사용자의 요구사항을 정확하게 준수했는지 확인하기 위해
- 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서
- 명세 기반 테스트의 설계 산출물
- 오류를 방지, 테스트 수행에 있어 낭비를 줄임

![Untitled](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/47aa05ea-6e4e-4f3c-bb8d-b09792271316)

- 작성 절차
    - 테스트 계획 검토 및 자료 확보 → 위험 평가 및 우선 순위 결정 → 테스트 요구사항 정의 → 테스트 구조 설계 및 테스트 방법 결정 → 테스트 케이스 정의 → 테스트 케이스 타당성 확인 및 유지보수 → 테스트 수행
- 테스트 케이스 자동 생성
    - 자료 흐름도 → 테스트 경로 관리, 입력 도메인 분석 → 테스트 데이터 산출, 램던 테스트 → 무작위 값 입력, 신뢰성 검사
- 테스트 케이스 작성 시 주의 사항
    - 목적 명확하게 정의
    - 입력 데이터와 예상 결과 정의
    - 실행 조건 고려
    - 예외 상황 고려
    - 테스트 결과 기록
    - 재사용성 고려
    - 관리 및 유지보수

## 테스트 케이스 구성 요소(ISO/IEC/IEEE 29119-3)

- 식별자(Identifier)
- 테스트 항목(Test Item)
- 입력 명세(INput Specification)
- 출력 명세(Output Specification) : 테스트 케이스 실행 시 기대 출력 결과
- 환경 설정(Environmental Needs) : 테스트 수행 시 필요한 H/W, S/W 환경
- 특수 절차 요구(Special Procedure Requirement)
- 의존성 기술(Interface Dependencies)

# 테스트 오라클(Test Oracle)

- 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법
- 예상되는 출력물 또는 동작이 무엇인지에 대한 식을 제공
- 소프트웨어의 품질 보장

| 테스트 오라클의 종류⭐ | 설명                                                          |
| --- |-------------------------------------------------------------|
| 참(True) 오라클 | 모든 입력값에 적합한 결과를 생성하여, 발생한 오류를 모두 검출                         |
| 일관성(Consistent) 검사 오라클 | 변경이 있을 떄, 수행 전과 후의 결과값이 동일한지 확인                             |
| 샘플링(Sampling) 오라클 | 대용량 데이터를 다루는 시스템에서 일부 데이터에 대해서 검증                           |
| 휴리스틱(Heuristic) 오라클  | 몇몇의 임의 입력값에 대해 올바른 결과를 제공하고, <br>나머지 값들에 대해서는 휴리스틱(추정)으로 처리 |

---

# 테스트의 분류

## 시각에 따른 테스트

- 검증(Verification) 테스트
    - 요구사항 명세서대로 완성되었는지 검증하는 단계
    - 개발자의 시각
- 확인(Validation) 테스트
    - 사용자의 요구사항을 잘 수행하고 있는지
    - 사용자의 시각에서

| 구분 | 검증 | 확인 |
| --- | --- | --- |
| 정의  | 요구사항 명세서에 따라 구현되었는 지 검증 | 실제 사용 환경에서 사용자의 요구사항을 충족시키는지 평가 |
| 목적 | 제품이 올바르게 설계 및 구현 되었는지 확인해 결함 최소화 | 사용자의 요구사항을 충족시키고 실제 사용환경에서 문제가 발생하지 않도록 보장 |
| 수행 시점 | 개발 중 Verification, 개발 완료 후 Validation | 제품 출시 전에 완료 |
| 검증 대상 | 문서, 코드, 디자인 등 제품 개발 과정의 산출물 | 제품 자체 및 제품이 사용되는 실제환경 |
| 수행 방법 | 검토, 검사, 정적 분석, 테스트 등  | 통합 테스트, 시스템 테스트, 인수 테스트 등 |
| 결함 발견  | 빨리 발견 | 출시 후 사용자로부터 발견되는 경우 많음 |
| 수정 비용 | 낮은 비용 | 높은 비용 |
| 테스트 기간 | 짧음 | 김 |
| 수행 단계 | 제품 개발 초기 단계 | 제품 개발 후 단계 |
| 결과 산출물 | 검증 보고서 | 검증 및 검사 보고서, 사용자의 피드백  |

## 테스트 기반(Test Bases)에 따른 테스트

- **구조 기반 테스트**
    - 내부의 구조(논리 흐름)에 따라 테스트 케이스를 작성하고 확인

| 구조 기반 테스트 종류 | 설명 |
| --- | --- |
| 구문 기반(Statement Testing) | 모든 문장을 한 번 이상 수행 |
| 결정 기반(Decision Testing) | 각 분기들을 한 번 이상 수행 |
| 조건 기반(Condition Testing) | 조건이 참이 되는 경우, 거짓이 되는 경우를 모두 수행 |
| 데이터 흐름(Data Flow Testing) | 테스트 경로를 선택  |
- **명세 기반 테스트**
    - 사용자의 요구사항에 대한 명세를 기반으로 테스트 케이스를 작성하고 확인
    - 종류 : 동등 분할, 경계값 분석, 분류 트리, 상태 전이, 결정 테이블, 원인-결과, 조합 테스트, 시나리오, 오류 추정
- **경험 기반 테스트**
    - 테스터의 경험을 기반으로 수행하는 테스트 방식
    - 에러 추정, 체크 리스트, 탐색적 테스팅

## 정적 테스트와 동적 테스트

- **정적 테스트**
    - 실행하지 않고 명세서나 소스코드를 대상으로 분석
    - 개발 초기에 결함 발견, 개발 비용 낮춤
    - 종류 : Inspection, Walk-Through, Code Test
- **동적 테스트**
    - 실행하여 오류를 찾는 테스트 방식
    - 개발의 모든 단계에서 수행
    - 종류 : **블랙박스 테스트**, **화이트박스** **테스트**
        - 블랙박스 테스팅 : Equivalence Partitioning, Cause and Effect Graphing, Error Forecast, Comparison Testing, Boundary Value Analysis
        - 화이트박스 테스팅 : Baisc Path Testing, Data Flow Testing
- **알파 테스트 (Alpha Test)**
    - 개발자 관점에서 수행
    - 개발자의 장소에서 사용자가 개발자 앞에서 수행
- **베타 테스트 (Beta Test)**
    - 선정된 다수의 사용자가 자신들의 사용 환경에서 일정 기간 사용하면서 테스트

## 테스트 목적에 따른 분류

- 회복 테스트(Recovery Testing) : 고의로 실패를 유도하고 복귀 여부를 테스트
- 안전 테스트(Security Testing) : 불법적인 소프트웨어가 시스템을 파괴하지 못하도록 점검
- 성능 테스트(Performance Testing) : 사용자 요구에 시스템이 반응하는 속도 등을 측정
    - **부하** 테스트(Load Testing) : 부하를 계속 증가시켜 임계점을 찾는 기법
    - **강도** 테스트(Stress Testing) : 임계점 이상의 부하를 가하여 비정상적인 상황에서의 처리 능력을 측정
    - 스파이크 테스트(Spike Testing) : 짧은 시간에 사용자가 몰릴 때 시스템의 반응을 측정
    - 내구성 테스트(Endurance Testing) : 오랜 시간 동안 시스템에 높은 부하를 가하여 시스템 반응을 확인
- 구조 테스트(Structure Testing) : 소스코드의 복잡도를 평가
- 회귀 테스트(Regression Testing) : 시스템의 변경에 새로운 결함이 없을 확인하는 기법
- 병행 테스트(Parallel Testing) : 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교

# 테스트와 V-모델

- 애플리케이션을 총체적으로 관리하기 위한 테스트 활동의 묶음
- 각각의 테스트 레벨은 독립적

![Untitled 1](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/d237a949-d366-47ea-9ef2-b8b1b99b1ca9)

| 테스트 레벨 종류 | 설명                                                                                                                                   |
| --- |--------------------------------------------------------------------------------------------------------------------------------------|
| 단위(Unit) 테스트 | 원시코드를 대상, 객체지향의 클래스 테스팅이 해당됨                                                                                                         |
| 통합 테스트 | 단위 테스트를 통과한 컴포넌트 간 인터페이스 및 연동 기능 등을 구조적으로 접근해 테스트                                                                                    |
| 시스템 테스트 | 기능상에 문제가 없는 상황에서 실제 환경과 유사한 환경에서 진행,                                                            <br>시스템 성능과 관련된 요구사항이 완벽하게 수행되는지 테스트 |
| 인수 테스트⭐ | 테스트 레벨의 가장 마지막 상위 레벨, 제품에 대한 요구사항이 제대로 이행 되었는지 확인,<br>실사용자 환경에서 진행, 수행하는 주체가 사용자,<br>알파, 베타 테스트                                      |

---

# 테스트 시나리오

- 테스트 케이스의 동작 순서를 기술 한 문서
- 절차, 사전 조건, 입력 데이터 등
- 테스트 시나리오 작성 시 유의점
    - 시스템 별, 모듈별, 항목별 테스트 시나리오를 분리
    - 테스트 항목은 식별자 번호, 순서 번호, 테스트 데이터, 테스트 케이스, 예상 결과, 확인 등의 항목을 포함함

## 테스트 환경 구축

- 실제 운영 시스템에서 정상적으로 작동하는지 테스트할 수 있도록 함
- 유형
    - 하드웨어 기반 : 서버, 클라이언트, 네트워크 장비 등의 장비를 설치
    - 소프트웨어 기반 : 응용 소프트웨어 설치
    - 가상 시스템 기반 : 가상 머신 기반의 서버 또는 클라우드 환경 이용

# 화이트박스 테스트(White Box Test)

- 원시 코드를 오픈시킨 상태에서 코드의 모든 논리적 경로를 테스트
- 소스 코드의 모든 문장을 한 번 이상 수행해 작동을 **직접 관찰**
- 동적 테스트
- 테스트 데이터를 선택하기 위해 검증 기준(Test Coverage)을 정함
- 장점
    - 테스트케이스 정확성과 효율성 향상
    - 코드 문제 및 개선 사항 파악 가능
    - 코드 디버깅 요이성 증가
    - 보안 취약점 발견 가능
- 화이트박스 테스트 검증 기준
    - 문장 검증 : 소스코드의 모든 구문이 한 번 이상 수행
    - 분기 검증 : 모든 조건문이 한 번 이상 수행
    - 조건 검증 : 모든 조건문에 대해 조건이 True인 경우와 False인 경우가 한 번 이상 수행
    - 분기/조건 : 모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우 한 번 이상 수행

## 화이트박스 테스트 종류

### 🔎 기초 경로 검사(Basic Path Testing)

- 절차적 설계의 논리적 복잡성을 측정할 수 있게 함
- 측정 결과는 실행 경로의 기초를 정의하는 데 지침으로 사용
- 기초 경로
    - 제어 흐름 그래프를 분석하여 선형 독립 실행 경로 집합을 찾음
    - McCabe의 순환 복잡도 사용해 **선형 독립 경로 수**를 결정한 다음 얻어진 각 경로에 대한 테스트 사례를 생성

### 🔎 제어 구조 검사

- 조건 검사
    - 논리적 조건을 테스트
- 루프 검사
    - 반복구조에 초점을 맞춤
- 데이터 흐름 검사
    - 변수의 정의와 사용의 위치에 초점을 맞춤

# 블랙박스 테스트(Black Box Test)

- 각 기능이 완전히 작동되는 것을 입증
- 구현된 기능 테스트
- 장점
    - 사용자 관점에서 테스트 : 내부 동작 원리 몰라도 됨
    - 시간과 비용 절약
    - 다양한 테스트 케이스 생성 가능 : 입력과 출력만으로 시스템을 테스트
    - 독립적인 테스트 수행 가능
- 블랙박스 테스트를 통해 찾을 수 있는 오류
    - 인터페이스 오류, 자료 구조상의 오류, 성능 오류,
    - 시작과 종결상의 오류, 부정확하거나 빠진 오류,
    - 비정상적인 자료를 입력해도 오류 처리를 수행하지 않는 경우,
    - 정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우,
    - 경계값을 입력할 경우 요구된 출력 결과가 나오지 않는 경우

## 블랙박스 테스트 종류

### 🔎 동치 분할 검사(Equivalence Partitioning)

- 입력 자료에 초점을 맞춰 테스트 케이스 생성하고 검사
- 입력 조건에 타당한 입력 자료와 그렇지 않은 자료의 개수를 **균등**하게 나눔

### 🔎 원인-효과 그래프 검사(Cause and Effect Graphing)

- 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석

### 🔎 오류 예측 검사(Error Forecast)

- 과거의 경험이나 감각으로 테스트
- 다른 테스트 기법으로 찾기 어려운 오류를 찾아냄

### 🔎 비교 검사(Comparison Testing)

- 동일한 테스트 자료를 여러 버전의 프로그램에 입력하고 동일한 결과가 출력되는지 테스트

### 🔎 경계값 분석(Boundary Value Analysis)

- 동치 분할 기법을 보완한 기법
- 분할의 경계 부분에 해당하는 입력 값에서 결함이 발견될 확률이 경험적으로 높음
- 예) 범위 : 1~100 , 테스트 : -1, 101

| 구분 | 화이트박스 테스트                                           | 블랙박스 테스트                                                      |
| --- |-----------------------------------------------------|---------------------------------------------------------------|
| 테스트 대상 | 소프트웨어의 내부 동작, 코드, 구조 등                              | 기능, 요구사항, 사용자 입장 등                                            |
| 목적 | 코드의 오류, 구조적 문제 등을 발견해 개선                            | 외부 요구사항을 만족하는지 확인                                             |
| 테스트 기법 | 구문 검사, 경로 검사, 데이터 흐름 검사 등                           | 덩치 분할 , 경계값 분석, 워크플로우 등                                       |
| 테스트 케이스 | 내부구조에 기반                                            | 사용자 관점                                                        |
| 테스트 수행자 | 개발자, 테스터                                            | 사용자, 테스터                                                      |
| 테스트 커버리지 | 문장, 분기, 경로 등을 테스트                                   | 요구사항, 사용자 시나리오 등을 테스트                                         |
| 장점 | 정확한 테스트 케이스 개발, <br>높은 테스트 정확성                      | 요구사항에 대한 검증이 쉬움                                               |
| 단점 | 변경 시 테스트 케이스 수정이 필요,           <br>개발자나 전문가에게만 적용가능 | 누락된 테스트 케이스가 있을 가능성이 있음,<br>테스트 케이스 설계 어려움,<br>오류 발견 후 수정 어려움 |

---

# 테스트 커버리지(Test Coverage)

- 품질 측정 기준
- 테스트의 정확성과 신뢰성을 향상시킴
- 테스트 케이스의 부족한 부분을 파악
- 100%는 테스트 중 모든 모수가 실행(커버)됨을 의미

![Untitled 2](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/cc9626fb-1530-4cc2-9051-dbcf24b48ea6)

| 테스트 커버리지 종류                                                                            | 설명                                                                                                                                                                     |
|----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 기능 커버리지(Function Coverage)                                                             | 전체 기능을 모수로 설정, 실제 테스트가 수행된 기능의 수를 측정                                                                                                                                   |
| 라인 커버리지(Line Coverage)                                                                 | Line 수를 모수로 설정, 단위 테스트에서 사용                                                                                                                                            |
| 코드 커버리지(Code Coverage)                                                                 | 테스트 충분성 지표 중 하나,<br>소스코드의 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 테스트 되었는지                                                                                                         |
| 구문 커버리지(Statement Coverage)                                                            | 모든 구문에 대해 한 번 이상 수행                                                                                                                                                    |
| 조건 커버리지(Condition Coverage)                                                            | 모든 개별 조건식에 대해 수행                                                                                                                                                       |
| 결정 커버리지(Decision Coverage)                                                             | 결정 포인트 내의 모든 분기문에 대해 최소 한 번씩 수행                                                                                                                                        |
| 조건/결정 커버리지<br>(Condition/Decision Coverage)                                            | 조건 + 결정 커버리지,                                                  <br> 전체 조건식과 개별 조건식이 참 한번, 거짓 한번을 모두 갖도록 함                                                              |
| 변경 조건/결정 커버리지<br>(Modified Condition/Decision Coverage) | 조건과 결정을 복합적으로 고려,                                                                                         <br>독립적으로 전체 조건식의 결과에 영향을 줌                                  |
| 다중 조건 커버리지<br>(Multiple Condition Coverage)          | 모든 개별 조건식의 모든 가능한 논리적 조합을 고려,                                                                                                         <br>가장 강력, 논리적 수준의 100% 커버리지를 보장 |

---

# 단위 테스트와 통합 테스트

## 단위 테스트(Unit Test)

- 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트
- 개발을 완료한 후 명세서의 내용대로 정확히 구현되었는지 테스트
- **구조적 테스트**
- 인터페이스, 자료구조, 독립적 기초 경로, 오류 처리 경로, 결제 조건 등을 테스트
- 단위 테스트 지원도구(xUnit)
    - JUnit, NUnit, JMockit, EMMA, PHPUnit, HttpUnit, DBUnit, CppUnit, PowerMock, Seleninum, …

## 통합 테스트(Integration Test)

- 각 모듈을 결합하여 시스템을 완성하는 과정에서 모듈 간 인터페이스 혹은 통합된 컴포넌트 간 상호작용 오류 및 결함을 찾아 해결하기 위한 테스트 기법
- 종류: 비 점진적 통합 방식(빅뱅 통합), 점진적 통합 방식(상향식/하향식)

| 비 점진적 통합 방식(빅뱅 통합) | 점진적 통합 방식(상향식/하향식) |
| --- | --- |
| 모든 모듈이 결합된 전체를 대상으로 테스트 | 단계적으로 통합하여 테스트 |
| 작은 규모 소프트웨어에 적합 | 오류 수정이 쉬움 |
| 오류 위치 파악 또는 수정 어려움 | 인터페이스 관련 오류 테스트 가능 |

![Untitled 3](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/4e8b653e-93d0-4fb7-a3f0-77da3e350a0b)

# 통합 테스트 방식

## 빅뱅 통합

- 모듈을 각각 따로 구현하고 전체 시스템을 한 번에 테스트
- 드라이버, 스텁 없이 실제 모듈들로 테스트 진행
- 단시간 테스트
- 결합의 격리가 어려움

## 하향식 통합 테스트

- 상위 컴포넌트를 테스트하고 점층적으로 하위 컴포넌트를 검사
- 주요 제어 모듈을 기준으로 아래로 통합
- 하위 컴포넌트 개발이 완료되지 않았을 때 **스텀(Stub)**사용
- 우선 통합법, 깊이 우선 통합법, 너비 우선 통합법 등
- 하위 레벨 모듈들은 특정한 소프트웨어 부가 기능을 수행하는 클러스터들에 결합

![Untitled 4](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/9942731e-0193-4d52-9a7f-e74c46f1d4be)

- 특징
    - 시스템 테스트 가능 : 모든 하위 모듈이 완성된 후 테스트
    - 개발 일정 예측 가능
    - 통합 오류를 찾기 어려움
    - 문제 발견이 늦어짐

## 상향식 통합 테스트

- 최하위 모듈을 구성하고 상위 모듈 방향으로 통합하며 검사

![Untitled 5](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/5bc425d5-756e-47dd-94a0-7705c62f249d)

- 하위 모듈의 결함이 상위 모듈로 전파되는 것을 방지
- 상위 모듈이 아직 개발 되지 않은 경우, 더미 모듈인 **드라이버(Driver)** 사용
- 개발 속도가 빠름
- 결함을 조기에 발견 가능
- 상향식 통합 테스트 사용 대상
    - 하위모듈의 개발이 상위보다 먼저 완료되는 경우
    - 개발속도 빠르게 하고 싶은 경우
    - 결함이 상위 모듈로 전파되는 것을 방지하고 싶은 경우
    - 개발이 순차적으로 진행되는 경우
- 유의 사항
    - 하위모듈은 독립적 테스트
    - 테스트 드라이버는 정확하게 구현해야함
    - 테스트 케이스는 하위 모듈의 모든 기능을 테스트
    - 상위모듈로 통합할 때 모듈의 의존성이 높아질 수 있도록 테스트 케이스를 신중히 설계
- 테스트 절차
    - 하위 모듈을 클러스터로 결합 → 상위모듈에서 드라이버 작성 → 통합된 클러스터 단위로 테스트 수행
    → 테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동해 결합하고 드라이버는 실제 모듈로 대체

## 샌드위치 통합 테스트

- 상향식 + 하향식
- 대규모 프로젝트에 사용
- 병렬 테스트 가능
- 스텁과 드라이버의 필요성이 매우 높음
- 비용이 많이 들어감

| 구분 | 하향식                                                | 상향식                                                        | 빅뱅                                                                         |
| --- |----------------------------------------------------|------------------------------------------------------------|----------------------------------------------------------------------------|
| 드라이버/스텁 | 스텁                                                 | 드라이버                                                       | 실제 모듈                                                                      |
| 수행 | 상위 → 하위                                            | 하위 → 상위                                                    | 동시                                                                         |
| 장점 | 장애 위치 확인 용이,<br>초기 프로토타입 가능                        | 장애 위치 확인 용이,<br>모든 모듈이 개발 준비되어 있지 않아도 됨                    | 소규모 시스템에 단기간 테스트                                                           |
| 단점 | 많은 스텁 필요,                   <br>낮은 수준 모듈은 부적절한 테스트 | 초기 프로토타입 불가,                <br>중요한 모듈들이 마지막에 테스트 될 가능성 높음 | 장애 위치 확인 어려움,                                      <br>모든 모듈이 개발 준비돼 있어야 함 |

# 테스트 자동화

## 테스트 자동화 도구

- 테스트 관리, 소스 코드 리뷰 및 인스펙션, 테스트 설계 및 개발, 테스트 수행 등 다양한 과정을 자동으로 지원
- 단계별 테스트 자동화 도구
    - 테스트 계획 단계 : 요구사항 관리 도구
    - 테스트 분석 및 설계 단계 : 테스트 케이스 생성 도구
    - 테스트 수행 단계 : 테스트 자동화/정적 분석/동적 분석/성능 테스트/모니터링 도구
    - 테스트 관리 단계 : 커버리지 분석/형상 관리/결함 추적 및 관리 도구

## 테스트 자동화 도구의 유형

- 정적 분석 도구
    - 프로그램을 실행하지 않고 소스코드 분석
- 테스트 실행 도구
    - 테스트를 실행
    - 종류
        - 데이터 주도 접근 방식 : 테스트 데이터
        - 키워드 주도 접근 방식 : 키워드 & 테스트 데이터
- 성능 테스트 도구
    - 처리량, 응답 시간, 경과 시간, 자원 사용량에 대해 가상의 사용자 생성 후 테스트
- 테스트 통제 도구
    - 테스트 계획 및 관리, 수행, 결함 관리
- 테스트 하네스 도구
    - 소프트웨어 컴포넌트를 테스트할 수 있게 하거나 프로그램의 입력을 받아들이거나
    - 빠진 컴포넌트의 기능을 대신하거나
    - 실행 결과와 예상결과를 비교하기 위함

### 🔎 테스트 하네스(Test Harness) 도구 구성 요소

![Untitled 6](https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/d742c7e2-afc5-4575-b2fe-121313bfaed5)

- Test Driver
    - 상향식 테스트에서 사용
    - 테스트 대상을 제어하고 동작시킴
    - 하위 모듈을 구동
    - 구현 비교적 어려움
    - Bottom-Up
    - 하위 모듈 중요도 높을 때
- Test Stub
    - 하향식 테스트에서 사용
    - 가상의 더미 컴포넌트
    - 하위 모듈을 대체
    - 구현 쉬움
    - Top-Down
    - 상위 모듈 중요도 높을 때
    - 테스트 어려움

| 구분  | Test Driver                                                | Test Stub                                         |
| --- |------------------------------------------------------------|---------------------------------------------------|
| 용도 | 하위 모듈을 구동                                                  | 하위 모듈을 대체                                         |
| 특징 | 구현이 비교적 어려움,<br>Bottom-Up 점층 통합,<br>하위 모듈 중요도 높을 때         | 구현이 쉬움,<br>Top-Down 점층 통합,<br>상위 모듈 중요도 높을 때      |
| 문제점 | 초기에 구조파악 어려움                                               | 입출력이 대부분 하위애 위치하여 테스트가 어려움                        |
| 차이 | 개발 완료 시 본래 모듈로 대체                                          | 기능을 임시로 수행하는 더미 모듈                                |
| 예 | 클라이언트 구축시 서버가 아직 준비되어 있지 않을 때 <br>서버(Driver)를 가상으로 만들어 테스트 | 서버는 준비되어 있고 클라이언트를 구축할 때 <br>클라이언트(Stub)를 가상으로 연결 |

- Test Suites
    - 일정한 순서에 의해 수행될 개별 테스트의 집합 또는 패키지
- Test Case
    - 요구에 맞게 개발 되었는지 확인하기 위해 입력과 예상 결과를 정의한 것
- Test Script
    - 테스트 케이스를 수행하여 그 결과를 보고할 목적으로
    - 명령어 또는 이벤트 중심의 스크립트 언어로 작성한 파일
- Mock Object
    - 테스트를 위해 사용자 행위를 미리 조건부로 입력해 두고
    - 그 상황에 맞는 행위를 수행하는 객체