# [소프트웨어개발] 5. 애플리케이션 성능 개선

# 결함관리

- 소프트웨어의 에러(Error), 결함(Defect), 결점(Fault), 버그(Bug), 실패(Failure) 같은 용어가 사용되며
- 이러한 결함으로 인해 설계와 다르게 동작하거나 다른 결과가 발생하는 것을 의미

| 결함 등급 가중치 | 예시 |
| --- | --- |
| 치명적 1.0 | 시스템 다운 |
| 주요 1.2 | 사용자 인터페이스 오류 |
| 보통 1 | 오타, 화면 레이아웃 문제 |
| 경미한 0.8 | 오타, UI 디자인 문제 |
| 단순 0.4 | 오타, 문자열 정렬  |

<img width="634" alt="Untitled" src="https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/91e45b06-44f5-4efc-aaf4-34e4ab688130">

- 결함 추적 프로세스
    - 등록, 검토, 할당, 수정, 결함 조치 보류, 재확인, 종료, 해제
- 오픈 소스 도구
    - Bugzilla, Mantis BT, Redmine, Trac, Test Link, Kiwi, TCMS, XQual, Test Disk, Apache JMeter

## 결함 관련 용어

- 에러(Error)
    - 개발 또는 유지보수 수행 중에 발생한 부정확한 결과
    - 개발자의 실수로 발생한 오타
- 오류(Fault)
    - 구현이나 설계상의 오류로 시스템이 고장(Failure)을 일으키게 함
    - 에러(Error)가 있는 경우 발생
    - 잘못된 연산자 사용, 변수 선언 오류, 데이터 유실
- 실패(Failure)
    - 정상적인 프로그램과 비정상적인 프로그램의 실행 결과의 차이
- 결함(Defect)
    - 버그, 에러, 오류, 실패 등의 전체를 포괄하는 용어

---

# 애플리케이션 성능 개선

| 성능 측정 지표 | 설명 |
| --- | --- |
| 처리량(Throughput) | 주어진 시간에 처리할 수 있는 프로세스 처리 수 |
| 응답시간(Response Time) | 데이터 입력 완료 시부터 응답 출력이 개시될 때까지 시간 |
| 경과 시간(Turnaround Time) | 입력한 시점 부터 그 결과의 출력이 완료할 때까지 걸리는 시간 |
| 자원 사용률(Resource Usage) | 프로세스 처리 중 사용하는 CPU 사용량, 메모리 사용량,네트워크 사용량 |
| 가용성(Availability) | 애플리케이션이 사용할 수 있는 시간의 비율 |
| 확장성(Scalability) | 더 많은 작업을 처리하기 위해 확장할 수 있는 능력 |
| 안정성(Reliability) | 애플리케이션이 일정 기간 잘 작동하는 정도 |

## 유형별 성능 분석 도구

- 성능/부하/스트레스(Performance/Load/Stress) 점검 도구
    - 처리량, 응답 시간, 경과 시간 등을 점검하기 위해 가
    - 상의 시스템 부하나 스트레스를 통해 성능을 분석하는 도구
- 모니터링(Monitoring) 도구
    - 성능 모니터링, 성능 저하 원인 분석, 시스템 부하량 분석, 장애 진단, 사용자 분석, 용량 산정 등의 기능을 통하여
    - 애플리케이션 실행 시 자원 사용량을 확인하고 분석하는 도구

## 위험 감시(Risk Monitoring)

- 위험 요소 징후들에 대하여 계속해서 인지하는 것
- 위험 감시 절차
    - 위험 식별(Risk Identification)
    - 위험 평가(Risk Assessment) : 위험의 우선순위 결정
    - 위험 대응 계획 수립(Risk Response Planning)
    - 위험 모니터링(Risk Monitoring) : 위험이 발생하면 즉시 대응 계획을 실행하고, 그 결과를 기록

# 애플리케이션 성능 저하 원인

- 데이터베이스 연결 및 쿼리 실행 시 발생하는 성능 저하 원인
    - **DB Lock** : 과도한 데이터 조회/업데이트/인덱스 생성 시 발생
    - **불필요한 DB Fetch** : 필요한 데이터보다 많은 대량의 데이터 요청이 들어오면 발생
    - **연결 누수(Connection Leak)** : 종료하지 않을 경우 발생
    - **부적절한 Connection Poll Size** : 커넥션 풀 크기가 너무 작거나 크게 설정하였을 때 발생
    - 기타 : 잘못 작성된 코드로 인해 발생
- 내부 로직으로 인한 성능 저하 원인
- 잘못된 환경 설정이나 네트워크 문제로 인한 성능 저하 원인

# 알고리즘 설계

- 알고리즘
    - 주어진 과제를 해결하는 방법과 절차
    - 자연어, 의사코드(Pseudocode), 순서도, 프로그래밍 언어를 이용하여 표현 가능

## 알고리즘 설계 기법

### 🔎 분할 정복법(Divide & Conquer)

- Top-Down방식
- 예) 퀵 정렬, 병합 정렬 알고리즘
- 장점
    - 병렬 처리 가능
    - 구현이 쉽고 단순
- 단점
    - 분할 단계에서의 오버헤드 발생 가능
    - 결합하는 과정으로 인해 추가적인 연산 시간이 필요
    - 문제를 잘게 분할하다 보면 오히려 문제해결 불가능
    
1. 분할(Divide): 분할이 가능한 부분까지 분할
2. 정복(Conquer): 분할한 하위 과제들을 모두 해결
3. 결합(Combine): 해결한 문제를 모두 결합

### 🔎 동적 계획법(Dynamic Programming)

- 주어진 문제를 해결하기 위해 부분 문제에 대한 답을 계속적으로 활용해 나감
- 속도는 빠르지만 공간 복잡도가 커지는 단점
- Bottom-Up 방식
- 예) 피보나치수열 알고리즘

1. 부분 문제로 분리
2. 가장 낮은 단계의 부분 문제 해답 계산
3. 부분문제의 해답을 이용해 상위 부분 문제를 해결

### 🔎 탐욕법(Greedy Method)

- 최적의 해결 방법을 구하는 기법
- 동적 계획법보다 효율적
- 예) 다익스트라 알고리즘
- 항상 최적해를 보장하지 않고 문제에 따라 Greedy Method가 적용되지 않을 수 있음

1. 문제를 부분 문제로 분리
2. 각 부분 문제에 대한 최적해 구함
3. 각 부분 문제의 최적해를 결합하여 전체 문제의 최적해를 구함

### 🔎 퇴각 검색법(Backtracking)

- 최적해를 구하기 위해 모든 가능성을 찾아가는 방법
- N-Queen 문제 해결 시에 응용됨

### 🔎 분기 한정범(Bound & Bound)

- 정해진 범위 (Bound)를 벗어나는 값들은 가지치기(Branch)해가며 결과값을 추적해 나가는 방식
- NP-Hard 문제 해결에 사용

## 알고리즘 시간 복잡도

- 시간 복잡도 : 알고리즘이 문제를 해결하기 위한 시간(연산)의 횟수

| Notation | 설명 |
| --- | --- |
| Big-O Notation | 알고리즘의 실행시간이 최악일 때 |
| Big-θ Notation | 알고리즘의 실행시간이 평균일 때 |
| Big-Ω Notation | 알고리즘의 실행시간이 최상일 때 |
- 정렬 방식 별 알고리즘 시간 복잡도

    | 종류 | 최상  | 평균 | 최악 |
    | --- | --- | --- | --- |
    | 선택 정렬 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ |
    | 버블 정렬 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ |
    | 삽입 정렬 | $O(n)$ | $O(n^2)$ | $O(n^2)$ |
    | 힙 정렬 | $O(n\log_2n)$ | $O(n\log_2n)$ | $O(n\log_2n)$ |
    | 병합 정렬 | $O(n\log_2n)$ | $O(n\log_2n)$ | $O(n\log_2n)$ |
    | 퀵 정렬 | $O(n\log_2n)$ | $O(n\log_2n)$ | $O(n^2)$ |

# McCabe 순환 복잡도(Cyclomatic) ⭐

- 소프트웨어의 복잡성을 측정하는 지표
- 프로그램의 이해 난이도는 제어 흐름 그래프의 복잡도에 따라 결정되며, 복잡도를 싸이클로메틱 개수로 산정하는 방법
- 싸이클로메틱 개수와 원시 프로그램 오류의 개수는 관계가 있음
- 10을 넘지 않도록 해야함

$$
\boxed{V(G)=E-N+2}\\E:화살표\ 수,\  N:노드\ 수
$$

<img width="248" alt="Untitled 1" src="https://github.com/saranghein/Engineer-Information-Processing/assets/98319061/2a047801-82c5-4218-9826-c050307835e3">

---

# 소스코드 최적화

- 클린 코드 : 좋은 코드
    - 작성 원칙: 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화
- 스파게티 코드(나쁜 코드) : 복잡한 코드
- 코드의 간결성 유지 지침
    - 복잡한 식은 괄호와 들여쓰기(Indentation)를 통해 표현
    - 빈 줄을 사용해 선언부와 구현부 구별

## 클린 코드의 작성 원칙⭐

- 가독성 : 쉬운 용어 사용
- 단순성 : 한 번에 한 가지 기능만 처리
- 의존성 배제 : 다른 모듈에 미치는 영향을 최소화
- 중복성 최소화 : 중복된 코드는 삭제
- 추상화 : 상위에서 간략하게 하위에서 상세내용 구현

## 외계인 코드(Alien Code)

- 오래되거나 참고 문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램

## 소스 코드 최적화 유형

- 클래스 분할 배치
- 좋은 이름 사용 : Naming Rule을 정의
- 코딩 형식 준수 : 호출하는 함수는 앞쪽에, 호출되는 함수는 뒤쪽에 배치
- 느슨한 결함(Loosely Coupled) : 의존성을 느슨하게 하도록 인터페이스 클래스 이용
- 적절한 주석

# 소스 코드 품질 분석

- 소스 코드 품질 분석 도구
    - 코딩 스타일, 코딩 표준, 복잡도, 메모리 누수 현상, 스레드 결함 등을 발견하기 위해 사용하는 분석 도구
    - 정적 분석 도구, 동적 분석 도구

## 정적 분석 도구

- 보안 약점 검출
- 소스코드에서 코딩의 복잡도, 모델 의존성, 불일치성 등을 분석
- 정적 분석 기법
    - 소스 코드 검증
    - 코드 리뷰 : 다른 개발자가 검토
    - 리버스 엔지니어링 : 기술적인 원리를 구조 분석을 통해 발견

| 종류 | 지원 언어 |
| --- | --- |
| PMD | Java, Apex, XML 등 |
| CPPCheck | C, C++ |
| SonarQube | 다양한 언어 |
| Checkstyle | Java |
| CCM | C, C++ |
| Cobertura | Java |

## 동적 분석 도구

- 소스코드보다는 실행과정에서 다양한 입출력 데이터의 변화 및 사용자 상호 작용에 따른 변화를 점검하는 분석 기법
- 동적 분석 기법
    - 디버깅
    - 스트레스 테스트 : 한계점에 이르는 테스트
    - 모의 해킹
    - 리버스 엔지니어링

| 종류 | 지원 언어 |
| --- | --- |
| Valgrind | C, C++, Assembly |
| GDB | C, C++, Assembly |
| JProfiler | Java |
| VisualVM | Java |
| Apache JMeter | Java |
| Fiddler | 다양한 언어, 프로토콜 |
| Avalanche | 다양한 언어, 프로토콜 |

| 구분 | 정적 분석 도구                                               | 동적 분석 도구                                                  |
| --- |--------------------------------------------------------|-----------------------------------------------------------|
| 작동 원리 | 코드를 실행하지 않고, 소스 코드 자체를 분석                              | 코드를 실행하여 동작 중에 발생하는 오류나 취약점을 찾음                           |
| 검사 대상 | 소스코드                                                   | 실행 중인 코드                                                  |
| 검사 시점 | 컴파일 이후, 빌드 이전에 수행                                      | 수행 중 또는 디버깅 중에 수행                                         |
| 오류 검출 | 코드 스타일, 복잡도, 보안 취약점 등                                  | 메모리 오류, 성능 문제, 보안 취약점 등                                   |
| 사용 예시 | 코드 품질 검사, 보안 검사, 버그 검사 등                               | 메모리 누수 검사, 성능 분석, 디버깅 등                                   |
| 수행하는 단계 | 소스 코드 작성 및 컴파일<br>→ 정적 분석 도구로 소스 코드 분석 <br>→ 결과 리포트 작성 | 소스 코드 작성 및 컴파일<br>→ 동적 분석 도구로 실행 중인 코드 분석 <br>→ 결과 리포트 작성 |